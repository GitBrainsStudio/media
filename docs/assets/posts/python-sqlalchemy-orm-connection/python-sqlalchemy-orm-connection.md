# Подключение SQLAlchemy ORM

**ORM (Object-Relational Mapping)** — это технология, которая позволяет сопоставлять модели, типы которых несовместимы. Например: таблица базы данных и объект языка программирования.

Иными словами, можно обращаться к объектам классов для управления данными в таблицах БД. Также можно создавать, изменять, удалять, фильтровать и, самое главное, наследовать объекты классов, сопоставленные с таблицами БД, что существенно сокращает наполнение кодовой базы.

Чтобы использовать возможности **SQLAlchemy**, необходимо понять принцип его работы.

Разработчикам, которые используют **jango-ORM**, придется немного перестроить образ мышления для создания ORM запросов. На мой взгляд, **SQLAlchemy** — функциональный монстр, возможностями которого можно и нужно пользоваться, но нужно понимать, что ORM не всегда идеальны. Поэтому обсудим моменты, когда использование этой технологии целесообразно.

В **SQLAlchemy** есть понятие декларативных и недекларативных определений моделей.

Недекларативные определения подразумевают использования mapper(), описывающего сопоставление каждой колонки БД и классом модели. В данной статье используется декларативное определение моделей.

Первым делом нам понадобится определить базовый класс:

```
from sqlalchemy.orm import declarative_base

Base = declarative_base()
```

И в качестве простого примера отлично впишется самая популярная модель пользователя: 

```
from sqlalchemy import Column, String
from sqlalchemy_utils import UUIDType

from Domain.Entities.Base import Base

class User(Base) : 

    __tablename__ = 'users'

    Id =  Column('id', UUIDType(binary=True), primary_key=True)
    Login = Column('login', String)
    FullName = Column('fullname', String)
```